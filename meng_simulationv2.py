# -*- coding: utf-8 -*-
"""MEng-simulationV2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ePEJRbw31UzyAxhcqJRUE6g-ZLFGchlC

# To Do List

* Connect new company transports to use company inventory (Elliot worked on 2/2)
  * Need to address when no transports or company inventory available, currently an index error.
* Record desired outputs when taking a time step (Elliot Completed 2/11)
  * Unmet Demand
  * Transports used
  * Expired Supply
* Implement resupply business rule
  * Scheduled transports every x days depending on platoon
  * Need to decide how much to resupply
  * Potential to add emergency transports
* Update the user inputs for new simulation (Adona & Lily attempting 2/2 -  not totally use what you are referring to so doing it on a different doc - scaled the platoons so it can take 3+ platoons under one company)
* Test above update (Adona & Lily adding new tests 2/2)
* Implement new Demand Function
  * use values from monte carlo simulations

* Update simulation code to run with new simulation
* Added docstrings for each class, method and functions in main code body - Stan ( 19.02)


#### Future Changes
* Enhance platoon location parameter, including future locations (Jay attempted 2/3, will need to discuss with ONR)
  * NATO uses the Military Grid Reference System (MGRS) which breaks the earth into grids and then 100,000m squares within those grids
  * We can ask the ONR how specific they want these location inputs to be and accomodate the code
* Make it so that transports can visit multiple platoons
* Optimize order transport assignments or allow for assignments to be an input

## Code Body
"""

from copy import Error
import numpy as np
import matplotlib.pyplot as plt
import math

class Transport:
  """ Class representing transport capabilities availiable for medicla logistics company
        Attributes :
          Speed - how fast can ttransport get to location 1 distance unit away in days
          Capacity - availiable cargo capacity in pints
          departureCount - days till the transport departs
          Name - Name of transport capability"""

  def __init__(self,sp,cap,count, name):
    self.speed = sp # speed 1 means it takes exactly loc number of days to deliver , speed 2 -> ceil(loc/2) and so on
    self.capacity = cap # capacity in pint
    self.departureCount = count # days till tranport is departs
    self.name = name

  def __str__(self):
    return f"Name: {self.name}. Departure Count: {self.departureCount}. Speed: {self.speed}. Capacity: {self.capacity}."

  def __repr__(self):
    return f"Name: {self.name}. Departure Count: {self.departureCount}. Speed: {self.speed}. Capacity: {self.capacity}."



class BloodInventoryUnit:
  """ This class represents units of Class VIIIB suplies thta can be stored and transported by company/platoon
      Attributes :
       ageUsable - amount of days left until product can no longer be used
       productType - specific type of product e.g. blood, plasma,etc.
       quantity - quantity in pints """
  def __init__(self, exp, prod, quant):
    self.ageUsable = exp #Days until the inventory expires
    self.productType = prod #The type of blood product
    self.quantity = quant #quantity in pints

  def hold(self):
    """
    This method represents holding blood inentory for 1 day,
   reducing ageUsable by 1
    """
    self.ageUsable -= 1

  def merge(self,other):
    """ This method merges two entries for inventory units of same type and age,
      adding up their quantities. For instance, it can be used when platoon receives
      supplies of same trype and age they already hold.
    """
    if (self.ageUsable == other.ageUsable) and (self.productType == other.ProductType):
      self.quantity = self.quantity + other.quantity
      other = None

  def __str__(self):
    return 'Age Usable: ' + str(self.ageUsable) + ' Product Type: ' + self.productType + ' Quantity: ' + str(self.quantity)

  def __repr__(self):
    return 'Product Type: ' + self.productType + '. Quantity: ' + str(self.quantity) + '. Age Usable: ' + str(self.ageUsable)

class BloodProductStorage:

  # inventory is a list of tuples containing (# of units, days until experation, days until arrival)
  def __init__(self, inventory):
    self.inventory = inventory

  def add(self, NumUnits, Exp, Arrival):
    bisect.insort((NumUnits, Exp, Arrival), self.inventory)

  def use(self, NumUnits):
    skips = 0
    while NumUnits > 0 and len(self.inventory) > skips:
      if self.inventory[i][2] > 0:
        skips += 1
      if self.inventory[skips][0] > NumUnits:
        self.inventory[skips][0] -= NumUnits
        NumUnits = 0
      else:
        NumUnits -= self.inventory[skips][0]
    return NumUnits

  def avail(self):
    return sum(i[0] for i in self.inventory if i[2] == 0)

  def timestep(self):
    self.inventory = [(i[0], i[1] - 1, i[2] - 1) for i in self.inventory]
    while self.inventory[0][1] <= 0:
      self.inventory.pop(0)

  def __str__(self):
    return 'Inventory: ' + str(self.inventory)


class Company:
  """ Class representing Medical Logistics Company
  Attributes :
  FWBinentoryArray - list of BloodInventoryUnit objects rpresenting current Fresh Whole Blood inventory of the company
  FWBinentoryArray - list of BloodInventoryUnit objects rpresenting current Plasma inventory of the company
  transportCapabilities - list of Transport objects representing transport capabilities availiable to company
  platoonList - list of platoons that is serviced by the company
   """
  def __init__(self, FWBinventory, Plasmainventory, transport, platoons):
    self.FWBinventoryArray = FWBinventory #List of BloodInventoryUnit with the productType 'FWB' that the Company has on hand
    self.PlasmainventoryArray = Plasmainventory #List of BloodInventoryUnit with the productType 'Plasma' that the Company has on hand
    self.transportCapabilities = transport #List of Transport objects that provide the transport available to the company for BloodInventoryUnit delivery
    self.platoonList = platoons #List of medical platoons that the company services


  def timeStep(self):
    """function that represents passing of 1 day in the simulation
      Returns : list with entries for that time step of
      [Transports used, [FWB unmet demand by platoon], [Plasma unmet demand by platoon], [Expired FWB by platoon], [Expired Plasma by platoon]] """
    for unit in self.transportCapabilities:
      unit.departureCount = max(unit.departureCount-1,0)

    for unit in self.FWBinventoryArray:
      unit.hold()
    for unit in self.PlasmainventoryArray:
      unit.hold()

    orders = []
    FWBUnmet = []
    PlasmaUnmet = []
    ExpiredFWB = []
    ExpiredPlasma = []
    for platoon in self.platoonList:
      demand, FWBU, PlasmaU, FWBE, PlasmaE = platoon.timeStep()
      orders.append(demand)
      FWBUnmet.append(FWBU)
      PlasmaUnmet.append(PlasmaU)
      ExpiredFWB.append(FWBE)
      ExpiredPlasma.append(PlasmaE)

    transportsUsed = self.orderPlanning(orders)
    return [transportsUsed, FWBUnmet, PlasmaUnmet, ExpiredFWB, ExpiredPlasma]


  def orderPlanning(self, orders):
    """function that counts transports used
       Args :
       orders - array of orders by platoons
       Returns :
       Number of transports used"""
    transNum = 0
    for i in range(len(orders)):
      if orders[i] != None:
        FWBonHand, PlasmaOnHand = self.findInventory(orders[i][0], orders[i][1])
        if len(FWBonHand) == 0 and len(PlasmaOnHand) == 0:
          orders[i] = None
      while orders[i] != None:
        if self.transportCapabilities[0].capacity >= orders[i][0] + orders[i][1]:
          for bloodInv in FWBonHand:
            self.platoonList[i].orderTracker[0].append(math.ceil(self.platoonList[i].location / self.transportCapabilities[0].speed) + self.transportCapabilities[0].departureCount)
            self.platoonList[i].orderTracker[1].append(bloodInv)
          for bloodInv in PlasmaOnHand:
            self.platoonList[i].orderTracker[0].append(math.ceil(self.platoonList[i].location / self.transportCapabilities[0].speed) + self.transportCapabilities[0].departureCount)
            self.platoonList[i].orderTracker[1].append(bloodInv)
          self.addTransport(Transport(self.transportCapabilities[0].speed, self.transportCapabilities[0].capacity, math.ceil(self.platoonList[i].location / self.transportCapabilities[0].speed)*2 + self.transportCapabilities[0].departureCount, self.transportCapabilities[0].name))
          self.transportCapabilities.pop(0)
          transNum += 1
          orders[i] = None
        else:
          cap = self.transportCapabilities[0].capacity
          while cap > 0:
            if orders[i][0] > 0:
              if FWBonHand[0].quantity > cap:
                FWBonHand[0].quantity -= cap
                self.platoonList[i].orderTracker[0].append(math.ceil(self.platoonList[i].location / self.transportCapabilities[0].speed) + self.transportCapabilities[0].departureCount)
                self.platoonList[i].orderTracker[1].append(BloodInventoryUnit(FWBonHand[0].ageUsable, FWBonHand[0].productType, cap))
                cap = 0
              else:
                self.platoonList[i].orderTracker[0].append(math.ceil(self.platoonList[i].location / self.transportCapabilities[0].speed) + self.transportCapabilities[0].departureCount)
                self.platoonList[i].orderTracker[1].append(FWBonHand[0])
                cap -= FWBonHand[0].quantity
                orders[i][0] -= FWBonHand[0].quantity
                FWBonHand.pop(0)
            else:
              if PlasmaOnHand[0].quantity > cap:
                PlasmaOnHand[0].quantity -= cap
                self.platoonList[i].orderTracker[0].append(math.ceil(self.platoonList[i].location / self.transportCapabilities[0].speed) + self.transportCapabilities[0].departureCount)
                self.platoonList[i].orderTracker[1].append(BloodInventoryUnit(PlasmaOnHand[0].ageUsable, PlasmaOnHand[0].productType, cap))
                cap = 0
              else:
                self.platoonList[i].orderTracker[0].append(math.ceil(self.platoonList[i].location / self.transportCapabilities[0].speed) + self.transportCapabilities[0].departureCount)
                self.platoonList[i].orderTracker[1].append(PlasmaOnHand[0])
                cap -= PlasmaOnHand[0].quantity
                orders[i][1] -= PlasmaOnHand[0].quantity
                PlasmaOnHand.pop(0)
          self.addTransport(Transport(self.transportCapabilities[0].speed, self.transportCapabilities[0].capacity, math.ceil(self.platoonList[i].location / self.transportCapabilities[0].speed)*2 + self.transportCapabilities[0].departureCount, self.transportCapabilities[0].name))
          self.transportCapabilities.pop(0)
          transNum += 1
    return transNum


  def findInventory(self, FWBNeed, PlasmaNeed):
    """ method used to find units of inventory that can be used to satisfy demand
        Args :
        FWBNeed - demand for FWB
        PlasmaNeed - demand for Plasma
        Returns :
        Arrays of FWB and Plasma inventory units that can be used to satisfy demand
     """
    FWB = []
    plasma = []
    while FWBNeed > 0:
      cur = self.FWBinventoryArray[0]
      if cur.quantity >= FWBNeed:
        added = BloodInventoryUnit(cur.ageUsable, cur.productType, FWBNeed)
        FWB.append(added)
        cur.quantity -= FWBNeed
        FWBNeed = 0
      else:
        FWBNeed -= cur.quantity
        FWB.append(cur)
        self.FWBinventoryArray.pop(0)
    while PlasmaNeed > 0:
      cur = self.PlasmainventoryArray[0]
      if cur.quantity >= PlasmaNeed:
        added = BloodInventoryUnit(cur.ageUsable, cur.productType, PlasmaNeed)
        plasma.append(added)
        cur.quantity -= PlasmaNeed
        PlasmaNeed = 0
      else:
        PlasmaNeed -= cur.quantity
        plasma.append(cur)
        self.PlasmainventoryArray.pop(0)
    return FWB, plasma

  def addInventory(self, order: BloodInventoryUnit):
    """ Method used to add blood-products to company's inventory
        Args :
        order - order represented as BloodInventory unit type object that represents product added"""
    if order.productType == 'FWB':
       for i in range(len(self.FWBinventoryArray)):
         if order.ageUsable < self.FWBinventoryArray[i].ageUsable:
           self.FWBinventoryArray.insert(i, order)
           return
       self.FWBinventoryArray.append(order)
       return
    if order.productType == 'Plasma':
      for i in range(len(self.PlasmainventoryArray)):
       if order.ageUsable < self.PlasmainventoryArray[i].ageUsable:
          self.PlasmainventoryArray.insert(i, order)
          return
      self.PlasmainventoryArray.append(order)
      return
    return Error('Invalid product type')

  def addTransport(self, transport: Transport):
    """ Method that adds transport capabilities to list of those availiable to company
        Args:
        transport - Transport object that represents transport capability to be added """
    for i in range(len(self.transportCapabilities)):
      if transport.departureCount < self.transportCapabilities[i].departureCount:
        self.transportCapabilities.insert(i, transport)
        return
    self.transportCapabilities.append(transport)

  def print(self):
    print('FWB Inventory: ' + str(self.FWBinventoryArray))
    print('Plasma Inventory: ' + str(self.PlasmainventoryArray))
    print('Transport Capabilities: ' + str(self.transportCapabilities))
    print('Platoons: ')
    for i in self.platoonList:
      i.print()



class Platoon:
  """ Class representing medical platton that is serviced by some Medical Logisstics Company
      Attributes :
      location - location is defined as time in days in which transport with speed 1 can deliver supplies
      FWBInventoryArray - array representing current inventory of Fresh Whole Blood availiable to platoon
      PlasmaInventoryArray - array representing current inventory of Plasma availiable to platoon
      combatLevelList - probabilities with which platoon is engaged in combat of certain intensity """
  def __init__(self, loc, FWBinventory, Plasmainventory, cl, orderInterval):
    self.location = loc #time to deliver to platoon in days
    self.FWBinventoryArray = FWBinventory # array of BloodInventoryUnit objects with the productType 'FWB' available to the platoon
    self.PlasmainventoryArray = Plasmainventory # array of BloodInventoryUnit objects with the productType 'Plasma' available to the platoon
    self.combatLevelList = cl #list of combat level probabilities, must sum to 1
    p = np.random.random()
    cumulative_cl = np.cumsum(cl)
    self.combatLevel = np.searchsorted(cumulative_cl, p) #The combat level on the current day sampled from
    self.orderCountDown = orderInterval
    self.runningDemand = [0,0]
    self.orderInterval = orderInterval
    self.orderTracker = [[], []]


  def updateCombatLevel(self):
    """ Method that updates the combat level based on combatLevelList for each new day"""
    p = np.random.random()
    cumulative_cl = np.cumsum(self.combatLevelList)
    self.combatLevel = np.searchsorted(cumulative_cl, p)


  def timeStep(self):
     """ Method that represents a day passing for the simulation. Updates the combat level, inentory, and order shipments

     """
     self.updateCombatLevel()
     for unit in self.FWBinventoryArray:
      unit.hold()
     for unit in self.PlasmainventoryArray:
       unit.hold()
     expiredFWB = 0
     expiredPlasma = 0
     while len(self.FWBinventoryArray) != 0 and self.FWBinventoryArray[0].ageUsable <= 0:
       expiredFWB += self.FWBinventoryArray[0].quantity
       self.FWBinventoryArray.pop(0)
     while len(self.PlasmainventoryArray) != 0 and self.PlasmainventoryArray[0].ageUsable <= 0:
       expiredPlasma += self.PlasmainventoryArray[0].quantity
       self.PlasmainventoryArray.pop(0)

     unMet, Demand = self.usage()
     self.runningDemand[0] += Demand[0]
     self.runningDemand[1] += Demand[1]
     self.orderCountDown -= 1

     orderDemand = None
     if self.orderCountDown == 0:
       orderDemand = self.placeOrder()
       self.orderCountDown = self.orderInterval

     popIndex = []
     for i in range(len(self.orderTracker[0])):
      if self.orderTracker[0][i] == 0:
        self.addInventory(self.orderTracker[1][i])
        popIndex.append(i)
      else:
        self.orderTracker[0][i] -= 1
     numPops = 0
     for i in popIndex:
      self.orderTracker[0].pop(i - numPops)
      self.orderTracker[1].pop(i - numPops)
      numPops += 1

     return orderDemand, unMet[0], unMet[1], expiredFWB, expiredPlasma


  def addInventory(self, order: BloodInventoryUnit):
    """ Method used to add blood-products to platoons's inventory
        Args :
        order - order represented as BloodInventory unit type object that represents product added
         Returns:
          an error if product added has invalid type"""
    if order.productType == 'FWB':
       for i in range(len(self.FWBinventoryArray)):
         if order.ageUsable < self.FWBinventoryArray[i].ageUsable:
           self.FWBinventoryArray.insert(i, order)
           return
       self.FWBinventoryArray.append(order)
       return
    if order.productType == 'Plasma':
      for i in range(len(self.PlasmainventoryArray)):
       if order.ageUsable < self.PlasmainventoryArray[i].ageUsable:
          self.PlasmainventoryArray.insert(i, order)
          return
      self.PlasmainventoryArray.append(order)
      return
    return Error('Invalid product type')


  def usage(self):
    """Method that represents usage of blood in 1 day of simulation. This method must be run together with timestep method.
        Returns :
        List of unmet demand for that day as a list with values for FWB and Plasma. If all demand is met the value is 0.
    """
    FWBDemand, PlasmaDemand = PlatoonDemand(self)
    FWBDemand = round(FWBDemand)
    PlasmaDemand = round(PlasmaDemand)
    Demand = [FWBDemand, PlasmaDemand]
    unMet = [0, 0]
    while FWBDemand >= 1:
      if len(self.FWBinventoryArray) == 0:
        unMet[0] = FWBDemand
        FWBDemand = -1
      else:
        avail = self.FWBinventoryArray[0].quantity
        if avail > FWBDemand:
          self.FWBinventoryArray[0].quantity -= FWBDemand
          FWBDemand = 0
        else:
          FWBDemand -= avail
          self.FWBinventoryArray.pop(0)
    while PlasmaDemand >= 1:
      if len(self.PlasmainventoryArray) == 0:
        unMet[1] = PlasmaDemand
        PlasmaDemand = -1
      else:
        avail = self.PlasmainventoryArray[0].quantity
        if avail > PlasmaDemand:
          self.PlasmainventoryArray[0].quantity -= PlasmaDemand
          PlasmaDemand = 0
        else:
          PlasmaDemand -= avail
          self.PlasmainventoryArray.pop(0)
    return unMet, Demand


  def totalInventory(self):
    """ Method that computes total inventory availiable to the platoon.
      Returns :
        inventory in FWB and Palsma quantities as a list."""
    FWB = 0
    Plasma = 0
    for i in self.FWBinventoryArray:
      FWB += i.quantity
    for i in self.PlasmainventoryArray:
      Plasma += i.quantity
    return [FWB, Plasma]


  def placeOrder(self):
    """ Method that etermines if an order needs to be placed by determining if the current inventory is below the given threshold.
        Returns :
        If an order is needed the order placement variable is updated to place this order.
    """
    orderDemand = self.runningDemand.copy()
    self.runningDemand = [0, 0]
    return orderDemand

  def print(self):
    print('Location: ' + str(self.location) + ' FWB Inventory: ' + str(self.FWBinventoryArray) + ' Plasma Inventory: ' + str(self.PlasmainventoryArray)
    + ' Combat Level: ' + str(self.combatLevel) + ' Time to Order: ' + str(self.orderCountDown)
    + ' Running Demand: ' + str(self.runningDemand) + ' Order Tracker: ' + str(self.orderTracker))


##
# Randomly samples the demand(in pints) for a given platoon
# Input the platoon that demand is needed for
# Output the Whole blood/red blood cell demand, plamsa demand
##
def PlatoonDemand(platoon):
  """ Function used to randomly sample demand for some platoon.
     Args :
     platoon - platoon for which demand is to be sampled
     Returns :
     Quantities of FWB and Plasma demanded.
  """
  numCasualities = 0
  if platoon.combatLevel == 0:
    numCasualities =  max(0,np.random.normal(platoon.combatLevel,platoon.combatLevel*0.5))
  elif platoon.combatLevel == 1:
    numCasualities =  max(0,np.random.normal(platoon.combatLevel,platoon.combatLevel*0.5))
  else:
    numCasualities =  max(0,np.random.normal(platoon.combatLevel,platoon.combatLevel*0.5))
  TransfusionsDemand = numCasualities * 0.2 * np.random.exponential(0.1116)*4815
  plasmaDemand = TransfusionsDemand * 0.02
  return TransfusionsDemand - plasmaDemand, plasmaDemand

"""## Platoon Code Testing"""

#input Cell
platoon1 = Platoon(2, [], [], [0.7, 0.2, 0.1], 3)
platoon1.addInventory(BloodInventoryUnit(10, 'FWB', 200))
platoon1.addInventory(BloodInventoryUnit(300, 'Plasma', 20))
platoon1.addInventory(BloodInventoryUnit(5, 'FWB', 1500))
platoon1.addInventory(BloodInventoryUnit(15, 'FWB', 1000))

# ARCHIVE
# output = platoon1.timeStep()
# print(output)
#The above code was used before Jan 28th. # Jay changed to the following:


print('Day', '[FWB, Plasma]')
for i in range(10+1): #iterate 10 days into the future
  output = platoon1.timeStep()
  if output==None: #no order is placed on this particular day
    output = [0, 0]
    print(i,' ', output)
  else:
    print(i,' ', output)

"""## Company Code Testing"""

platoon1 = Platoon(2, [], [], [0.7, 0.2, 0.1], 3)
platoon1.addInventory(BloodInventoryUnit(10, 'FWB', 200))
platoon1.addInventory(BloodInventoryUnit(300, 'Plasma', 20))
platoon1.addInventory(BloodInventoryUnit(5, 'FWB', 1500))
platoon1.addInventory(BloodInventoryUnit(15, 'FWB', 1000))

platoon2 = Platoon(3, [], [], [0.85, 0.1, 0.05], 4)
platoon2.addInventory(BloodInventoryUnit(10, 'FWB', 200))
platoon2.addInventory(BloodInventoryUnit(300, 'Plasma', 50))
platoon2.addInventory(BloodInventoryUnit(5, 'FWB', 1500))
platoon2.addInventory(BloodInventoryUnit(15, 'FWB', 1000))

company1 = Company([], [], [], [platoon1, platoon2])
company1.addTransport(Transport(1, 10000, 2, '1'))
company1.addTransport(Transport(2, 10000, 5, '2'))
company1.addTransport(Transport(2, 10000, 6, '3'))
company1.addTransport(Transport(1, 10000, 6, '4'))
company1.addTransport(Transport(1, 10000, 8, '5'))

company1.addInventory(BloodInventoryUnit(40, 'FWB', 2000))
company1.addInventory(BloodInventoryUnit(300, 'Plasma', 2000))
company1.addInventory(BloodInventoryUnit(10, 'FWB', 15000))
company1.addInventory(BloodInventoryUnit(15, 'FWB', 10000))

company1.print()

output = company1.timeStep()
company1.print()
print(output)

"""## User Input"""

T = 100 #Number of days simulated
n = 2 #Number of Platoons
l = [3, 2] #List of length n of the Locations of each platoon as an integer number of days from company location
ReOrderTime = [3, 4] # List of length n of the time between reorders for each platoon as an integer number of days
I = [[[10, 'FWB', 750], [300, 'Plasma', 30]], [[20, 'Plasma', 40], [5, 'FWB', 300], [20, 'FWB', 800]]] #List of length n with an entry for each platoon. Each entry is the platoon current inventory represented by a list of lists of format
# [Days until Expired, Type of blood, number of units]
IC = [[10, 'FWB', 750], [300, 'Plasma', 30], [20, 'Plasma', 40], [5, 'FWB', 300], [20, 'FWB', 800]] #List of current company inventory in the form [Days until Expired, Type of blood, number of units]
TransportList = [[1, 10000, 2, '1'], [2, 10000, 5, '2'], [2, 10000, 6, '3'], [1, 10000, 6, '4'], [1, 10000, 8, '5']] # List of transports available for the company in the form of [Speed, Capacity, Days until Departure, Name]
CLMatrix = [[0.7, 0.2, 0.1], [0.75, 0.2, 0.05]] #List of length n of a list of the probability of being at each combat level 0 to 4 for each platoon. Probabilities must add to 1.

#lily and adona added
def initializePlatoons(n,l,I,CLMatrix, ReOrderTime):
  platoons = []
  for i in range(n):
      FWBInv = [BloodInventoryUnit(item[0],item[1],item[2]) for item in I[i] if item[1]=="FWB"]
      PlasmaInv = [BloodInventoryUnit(item[0],item[1],item[2]) for item in I[i] if item[1]=="Plasma"]
      platoons.append(Platoon(l[i], FWBInv, PlasmaInv, CLMatrix[i], ReOrderTime[i]))
  return platoons

platoons = initializePlatoons(n,l,I,CLMatrix, ReOrderTime)

#lily and adona added tests
#verifying length platoons
assert len(platoons) == n, f"Expected {n}, got {len(platoons)}"

#check inventory initialization
for i in range(n):
    total_inventory = len(platoons[i].FWBinventoryArray) + len(platoons[i].PlasmainventoryArray)
    expected_inventory = len(I[i])
    assert total_inventory == expected_inventory, f"Platoon {i} inventory mismatch"

#checking combat level probabilty check
for i in range(n):
    assert round(sum(CLMatrix[i]), 2) == 1.0, f"Combat level probabilities for platoon {i+1} do not sum to 1"

#testing that the code can handle large amounts of inventory
I_large = [[[10, 'FWB', 50000], [300, 'Plasma', 20000]] for _ in range(n)]
test_platoons = initializePlatoons(n, l, I_large, CLMatrix, ReOrderTime)
assert all(sum(item.quantity for item in p.FWBinventoryArray) > 10000 for p in test_platoons), "Platoons should handle large inventories"

def initializeCompany(platoons, IC, Transport):
  Company1 = Company([], [], [], platoons)
  for i in IC:
    Company1.addInventory(BloodInventoryUnit(i[0], i[1], i[2]))
  for i in TransportList:
    Company1.addTransport(Transport(i[0], i[1], i[2], i[3]))

  return Company1

Company1 = initializeCompany(platoons, IC, Transport)

"""## User Input Simulation Test"""

Company1.print()

output = company1.timeStep()
company1.print()
print(output)

"""## Simulation"""

!pip install scikit-optimize
from skopt import gp_minimize

def sim(inputs):
  simQR = [[[inputs[0], inputs[1]], [inputs[2], inputs[3]]], [[inputs[4], inputs[5]], [inputs[6], inputs[7]]]]
  platoons = []
  for i in range(n):
    FWBInv = []
    PlasmaInv = []
    for j in I[i]:
      if j[1] == 'FWB':
       FWBInv.append(BloodInventoryUnit(j[0], j[1], j[2]))
      if j[1] == 'Plasma':
        PlasmaInv.append(BloodInventoryUnit(j[0], j[1], j[2]))
    platoons.append(Platoon(l[i], FWBInv, PlasmaInv, CLMatrix[i], simQR[i]))

  Company1 = Company([], [], [], platoons)
  result = []
  for i in range(T):
    output = Company1.timeStep()
    result.append(output)

  result = np.array(result).T
  k = 10
  rawScore = 0
  maxUnmet = 0
  for i in result:
    rawScore += sum(i[0]) + sum(i[1])
    for j in i[0]:
      if j > maxUnmet:
        maxUnmet = j
    for j in i[1]:
      if j > maxUnmet:
        maxUnmet = j
  rawScore += maxUnmet * k
  normalizeScore = rawScore / (n*T)
  return normalizeScore

bounds = [(200, 800), (500, 2000), (0, 15), (10, 50), (200, 800), (500, 2000), (0, 15), (10, 50)]

result = gp_minimize(sim, bounds, n_calls=100)
print(f"Best configuration: {result.x} with score: {result.fun}")

